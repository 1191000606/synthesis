# 这个脚本用于计算物体的世界变换矩阵world_transform

import numpy as np

Rs = np.array([
    [0.2, 0, 0, 0],
    [0, 0.2, 0, 0],
    [0, 0, 0.2, 0],
    [0, 0, 0, 1],
])

Rt = np.array([
    [1, 0, 0, 0.5],
    [0, 1, 0, 0],
    [0, 0, 1, 0.1],
    [0, 0, 0, 1],
])

Rx = np.array([
    [1, 0, 0, 0],
    [0, 0, 1, 0],
    [0, -1, 0, 0],
    [0, 0, 0, 1],
])

Ry = np.array([
    [1/2, 0, np.sqrt(3)/2, 0],
    [0, 1, 0, 0],
    [-np.sqrt(3)/2, 0, 1/2, 0],
    [0, 0, 0, 1],
])

Rz = np.array([
    [-1, 0, 0, 0],
    [0, -1, 0, 0],
    [0, 0, 1, 0],
    [0, 0, 0, 1],
])

# 由于是points_homo @ world_transform
# 注意由scene.py文件可得，isaac sim采用的是内旋
# 正常的次序应该是 transform @ point_cloud，这时候 transform = Rt @ Rx @ Ry @ Rz @ Rs 
a = (Rt @ Rx @ Ry @ Rz @ Rs).T

print(a)



# Gf.Matrix4d(-0.10000026870763346, 0.17320492560872428, -1.8103654262730813e-06, 0.0,
#             1.0050377833435094e-06, 2.670692718360936e-06, 0.19999999997964327, 0.0,
#             0.17320492561526948, 0.10000026868835758, -2.2057374198996254e-06, 0.0,
#             0.5000003576278688, 1.3993465017666753e-06, 0.10435238480567932, 1.0)